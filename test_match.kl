
// if-match
import "io"

z := 100
if 100 ~= z {
  io.println("100 ~= z")
}

if z ~= 100 {
  io.println("z ~= 100")
}

if 100 + z ~= 200 {
  io.println("100 + z ~= 200")
}


var y string = "foo"

var x int = 200

import "io"
zz := (100, "foo")
if (x, y) ~= zz {
  io.println("if-match")
  io.println(x + 1)
  io.println(y)
} else {
  io.println("not if-match")
}

if (_, y) ~= zz {
  io.println("if-match")
  io.println(y)
}

if (100, y + 1) ~= zz {
  io.println("if-match")
  io.println(y)
}

zz2 := (100, (200, 300), "foo")

if (100, (200, x), y) ~= zz2 {
  io.println("if-match")
  io.println(x)
  io.println(y)
}

if (100, (200, _), _) ~= zz2 {
  io.println("if-match2")
}

arr := [(100, "foo"), (200, "bar"), (404, "not found")]
// for statement: variable and tuple only
for (x, y) in arr {

}

// match-statement
import "io"
if Result.Ok(100) ~= Result.<int, string>.Ok(100) {
  io.println("Result.Ok(100) ~= Result.Ok(100)")
}

if Result.Ok(x) ~= Result.<int, string>.Ok(100) {
  io.println("Result.Ok(x) ~= Result.Ok(100)")
  io.println(x)
}

ok := Result.<int, string>.Ok(100)
if Result.Ok(x) ~= ok {
  io.println("Result.Ok(x) ~= ok")
  io.println(x)
}

ok2 := Result.<string, string>.Ok("foo")
if ok2 ~= ok {
  io.println("ok2 ~= ok")
}

ok3 := Result.<(int, string), int>.Ok((100, "foo"))
ok3.ok()
if Result.Ok((_, y)) ~= ok3 {
  io.println("Result.Ok((_, y)) ~= ok3")
  io.println(y)
}

if Result.Ok(x) ~= Result.<int,int>.Err(100) {
  io.println("Result.Ok(x) ~= Result.Err(100)")
  io.println(x)
}

/////////////////////////////////////////////////////////////////////////////

i := 100
import "io"

match i {
}

match i {
  _ => {}
}

match i {
  _ => io.println("i == i");
}

match i {
  100 => io.println("i == 100")
  200 => io.println("i == 200")
  _ => io.println("i != 100 and i != 200")
}

i = 200

match i {
  _ => io.println("i != 100 and i != 200")
  100 => io.println("i == 100")
  200 => io.println("i == 200")
}

i = 300

match i {
  100 => io.println("i == 100")
  _ => io.println("i != 100 and i != 200")
  200 => io.println("i == 200")
}

match i {
  100 => io.println("i == 100")
  300 => io.println("i == 300")
  200 => io.println("i == 200")
}

match i {
  1...10 => io.println("1...10")
  _ => io.println("out of 1...10")
}

match i {
  true => io.println("true")
  false => io.println("false")
}

match false {
  true => io.println("true")
  false => io.println("false")
}

match true {
  true => io.println("true")
  false => io.println("false")
}

i = 20

match i {
  20 => {
    io.println("i == 100")
    j := i
    sum := 0
    while j > 0 {
      if (j < 10) {
        break
      }
      sum += 1
      j -= 1
    }
    io.println(sum)
  },
  _ => io.println("i != 20"),
}

i = 100

match i {
  1 | 3 | 100 | 300 => io.println("1 | 3 | 100 | 300")
  2 | 4 | 200 | 500 => io.println("2 | 4 | 200 | 500")
  _ => io.println("other value")
}

match i {
  20...200 => io.println("20...200")
  _ => io.println("other value")
}

/*
if obj is any, others are not allowed.
match obj {
  is int => io.println("type of obj is int")
  is string => io.println("type of obj is string")
  _ => io.println("type of obj is others")
}
*/

enum Option {
  None,
  Some(int, string),

  func is_some() bool {
    return (self == None) ? false : true
  }

  func is_none() bool {
    return (self == None) ? true : false
  }
}

opt := Option.Some(100, "foo")

match opt {
  case Option.Some(100, "foo") => io.println("Option.Some(100, \"foo\")")
  case 1 | 3 | 100 | 300 => io.println("1 | 3 | 100 | 300")
  123 => io.println("opt is 123")
  _ => io.println("not Option.Some(100, \"foo\")")
}

match opt {
  Option.Some(200, "foo") => io.println("Option.Some(200, \"foo\")")
  Option.Some(100, "foo") => io.println("Option.Some(100, \"foo\")")
  Option.None => io.println("Option.None")
  _ => io.println("not Option.Some(100, \"foo\")")
}

match opt {
  Option.Some(_, "bar") => io.println("Option.Some(_, \"bar\")")
  Option.Some(_, "foo") => io.println("Option.Some(_, \"foo\")")
  _ => io.println("not Option.Some(_, \"foo\")")
}

opt = Option.None

match opt {
  Option.Some(200, "foo") => io.println("Option.Some(200, \"foo\")")
  Option.Some(100, "foo") => io.println("Option.Some(100, \"foo\")")
  Option.None => io.println("Option.None")
  _ => io.println("not Option.Some(100, \"foo\")")
}

match opt {
  Option.Some(_, y) => {
    io.println("Option.Some(_, y)")
    io.println(y)
  },
  _ => io.println("not Option.Some(_, y)")
}

opt = Option.Some(100, "jack&rose");

match opt {
  Option.Some(_, y) => {
    io.println("Option.Some(_, y)")
    io.println(y)
  },
  _ => io.println("not Option.Some(_, y)")
}

match opt {
  Option.Some(x, y) => {
    io.println("Option.Some(x, y)")
    io.println(x); io.println(y)
  }
  _ => io.println("not Option.Some(x, y)")
}

match opt {
  Option.Some(100, x) => {
    io.println("""
    Option.Some(100, x)
    """)
    io.println(x)
  }
  Option.Some(200, x) => {
    io.println("Option.Some(200, x)")
    io.println(x)
  }
  Option.None => io.println("Option.None")
  _ => io.println("not Option.Some(100, x)")
}

opt = Option.Some(200, "foo&bar");

match opt {
  Option.Some(100, x) => {
    io.println("Option.Some(100, x)")
    io.println(x)
  }
  Option.Some(200, x) => {
    io.println("""Option.Some(200, x)""")
    io.println(x)
  }
  Option.None => io.println("Option.None")
  _ => io.println("not Option.Some(100, x)")
}

opt = Option.None

match opt {
  Option.Some(100, x) => {
    io.println("Option.Some(100, x)")
    io.println(x)
  }
  Option.Some(200, x) => {
    io.println("Option.Some(200, x)")
    io.println(x)
  }
  Option.None => io.println("Option.None")
  _ => io.println("not Option.Some(100, x)")
}

/*
// short for match enum with only two cases

if Option.Some(100, "foo") = opt {
  // Option.Some
  io.println("Option.Some(100, \"foo\")")
} else {
  // others, except Option.Some
  io.println("not Option.Some(100, \"foo\")")
}

if Option.Some(_, "foo") = opt {
  // Option.Some
  io.println("Option.Some(_, \"foo\")")
} else {
  // others, except Option.Some
  io.println("not Option.Some(_, \"foo\")")
}

if Option.Some(_, y) = opt {
  // Option.Some
  io.println("Option.Some(_, y)")
  io.println(y)
} else {
  // others, except Option.Some
  io.println("not Option.Some(_, y)")
}

if Option.Some(x, y) = opt {
  // Option.Some

} else {
  // others, except Option.Some
}
*/
